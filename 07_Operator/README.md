# 7장 연산자

<br>

```
연산자는 하나 이상의 표현식을 대상으로 산술, 할당, 비교, 논리, 타입, 지수 연산 등을 수행 → 하나의 값을 만듬

피연산자 = "값"
연산자 = "피연산자를 연산 → 새로운 값을 만듬"
```

<br>
<br>

## 7.1 산술 연산자

```
피연산자를 대상으로 수학적 계산을 수행해 새로운 숫자 값을 만듬
산술 연산이 불가능한 경우, NaN 반환
```

- **이항 산술 연산자** : **2개**의 피연산자를 산술 연산하여 숫자 값 만듬

  > 피연산자의 값을 변경하는 부수 효과 없음.

  - \+ : 덧셈
  - \- : 뺄셈
  - \* : 곱셈
  - / : 나눗셈
  - % : 나머지

  <br>

- **단항 산술 연산자** : **1개**의 피연산자를 산술 연산하여 숫자 값을 만듬

  - ++ : 증가
  - \-- : 감소
  - \+ : 어떠한 효과 없다.
  - \- : 양수를 음수로, 음수를 양수로 반전

```js
// 피연산자 앞에 위치, 값을 증가/감소 → 다른 연산 수행
// 피연산자 뒤에 위치, 다른 연산 수행 → 값을 증가/감소

var x = 5,
  result;

// 선할당 후 증가 (postfix increment operator)
result = x++;
console.log(result, x); // 5 6

// 선증가 후 할당 (prefix increment operator)
result = ++x;
console.log(result, x); // 7 7

// 선할당 후 감소 (postfix decrement operator)
result = x--;
console.log(result, x); // 7 6

// 선감소 후 할당 (prefix decrement operator)
result = --x;
console.log(result, x); // 5 5
```

```js
// 💡 숫자 타입 아닌 피연산자에 + 단항 연산자 사용하면 피연산자를 숫자 타입으로 변환 (피연산자를 변경하는 것은 아니고 숫자 타입으로 변환한 값을 생성해서 반환하기 때문에 부수 효과는 없음)

var x = "1";

console.log(+x); // 1

var x = true;
console.log(+x); // 1

var x = "Hello";
console.log(+x); // NaN, 문자열을 숫자 타입으로 변환할 수 없음
```

```js
// 💡 - 단항 연산자는 피연산자의 부호를 반전한 값을 반환, 숫자 타입이 아닌 피연산자에 사용하면 숫자 타입으로 변환하여 반환

-(-10); // 10

-"10"; // -10

-true; // -1
```

<br>
<br>

## 7.2 할당 연산자

```
할당 연산자는 우항에 있는 피연산자의 평가 결과를 좌항에 있는 변수에 할당

부수효과 O

x  = 5 : x = 5
x += 5 : x = x + 5
x -= 5 : x = x - 5
x *= 5 : x = x * 5
x /= 5 : x = x / 5
x %= 5 : x = x % 5
```

<br>

할당문은 표현식인 문일까? → O, **할당문은 값으로 평가되는 표현식인 문으로서 할당된 값으로 평가됨**

```js
var a, b, c;

// 연쇄 할당, 오른쪽에서 왼쪽으로 진행.
a = b = c = 0;

console.log(a, b, c); // 0 0 0
```

<br>
<br>

## 7.3 비교 연산자

| 비교 연산자 | 의미        | 사례    | 설명                    | 부수효과 |
| ----------- | ----------- | ------- | ----------------------- | -------- |
| ==          | 동등 비교   | x == y  | x, y의 값이 같음        | X        |
| ===         | 일치 비교   | x === y | x, y의 값과 타입이 같음 | X        |
| !=          | 부동등 비교 | x != y  | x, y의 값이 다름        | X        |
| !==         | 불일치 비교 | x !== y | x, y의 값이 타입이 다름 | X        |

💡 동등 비교 연산자는 좌항과 우항의 피연산자를 비교할 때 먼저 **암묵적 타입 변환**을 통해 타입을 일치시킨 후 같은 값인지 비교하기 때문에 결과를 예측하기 어렵고 실수하기 쉽다. 따라서 **일치 비교 연산자를 사용**한다

```js
// 일치비교 연산자에서는 NaN 주의 !
// NaN 은 자신과 일치하지 않는 유일한 값

NaN === NaN; // false

// 💡 숫자가 NaN인지 조사하려면 빌트인 함수 Number.isNaN을 사용
Number.isNaN(NaN); // true
Number.isNaN(10); // false
Number.isNaN(1 + undefined); // true
```

<br>

📄 `Object.is` 메서드는 예측 가능한 정확한 비교 결과 반환

ex) Object.is(-0,+0); // → false

<br>
<br>

## 7.5 논리 연산자

| 논리 연산자 | 의미        | 부수효과 |
| ----------- | ----------- | -------- |
| \|\|        | 논리합(OR)  | X        |
| &&          | 논리곱(AND) | X        |
| !           | 부정(NOT)   | X        |

```js
// 암묵적 타입 변환
// 피연산자가 불리언 값이 아니면 불리언 타입으로 암묵적 타입 변환

!0; // true
!"Hello"; // false
```

```js
// 단축 평가
// 논리합 또는 논리곱 연산자 표현식은 언제나 2개의 피연산자 중 어느 한쪽으로 평가

"Cat" && "Dog"; // "Dog"
```

📄 **드 모르간의 법칙**을 활용하면 가독성 좋은 표현식으로 변환할 수 있다.

<br>
<br>

## 7.8 typeof 연산자

```
피연산자의 데이터 타입을 문자열 "string", "number", "boolean", "undefined", "symbol", "object", "function" 중 하나로 반환

typeof로 null 값을 연산해보면 "object"를 반환 하는 버그가 있다. 주의 !
```

<br>
<br>

## 7.9 지수 연산자

```
ES7에서 도입된 지수 연산자는 좌항의 피연산자를 밑으로, 우항의 피연산자를 지수로 거듭제곱하여 숫자 값 반환
```

```js
// 지수 연산자의 결합 순서는 우항에서 좌항

2 ** 2; // 4
2 ** 0; // 1
2 ** -2; // 0.25

// 할당 연산자와 함께 사용 가능
var num = 5;
num **= 2; // 25

// 이항 연산자 중 우선순위 가장 높음
2 * 5 ** 2; // 50

// 이전에 사용하던 Math.pow 메서드보다 가독성 좋음
```

<br>
<br>

## 7.11 연산자의 부수 효과

```
할당연산자(=), 증가/감소 연산자(++/--), delete 연산자는 부수효과가 있다.
```

<br>
<br>

## 7.12 연산자 우선순위

> 연산자는 종류가 많아 연산자 우선순위를 모두 기억하기 어렵고 실수 하기도 쉽기때문에 **_그룹 연산자_** 를 사용하여 우선순위를 명시적으로 조절하는 것을 권장한다.

<br>
<br>

## 7.13 연산자 결합 순서

```
연산자 결합 순서란 연산자의 어느 쪽부터 평가를 수행할 것인지를 나타내는 순서를 말한다
```

<br>
