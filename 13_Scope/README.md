# 13장 스코프

<br>
<br>

## 13.1 스코프란?

scope는 모든 프로그래밍 언어의 기본적이며 중요한 개념

```js
function add(x, y) {
  // 매개변수는 함수 몸체 내부에서만 참조 가능
  // 즉, 매개변수의 스코프는 함수 몸체 내부
  console.log(x, y); // 2 5
  return x + y;
}

add(2, 5);

// 매개변수는 함수 몸체 내부에서만 참조 가능하다.
console.log(x, y); // ReferenceError
```

변수는 코드의 가장 바깥 영역, 코드 블록이나 함수 몸체 내에서도 선언 가능

```js
var var1 = 1; // 코드의 가장 바깥 영역에서 선언한 변수

if (true) {
  var var2 = 2; // 코드 블록 내에서 선언한 변수
  if (true) {
    var var3 = 3; // 중첩된 코드 블록 내에서 선언한 변수
  }
}

function foo() {
  var var4 = 4; // 함수 내에서 선언한 변수

  function bar() {
    var var5 = 5; // 중첩된 함수 내에서 선언한 변수
  }
}

console.log(var1); // 1
console.log(var2); // 2
console.log(var3); // 3
console.log(var4); // ReferenceError
console.log(var5); // ReferenceError
```

💡 모든 식별자는 자신이 선언된 위치에 의해 다른 코드가 식별자 자신을 참조할 수 있는 **_유효 범위(Scope)_** 가 결정됨

📄 코드의 문맥(context)은 코드가 어디서 실행되며 주변에 어떤 코드가 있는지를 나타내는 **_렉시컬 환경_** 으로 이뤄지는데, **모든 코드는 실행 컨텍스트에서 평가되고 실행**된다. (23장 "실행 컨텍스트"에서 자세히!)

<br>

📄 var 키워드로 선언한 변수의 중복 선언

`var`키워드로 선언된 변수는 `let`, `const`와 달리 같은 스코프 내에서 중복 선언이 허용 → 의도치 않게 변수값이 재할당되어 변경되는 부작용을 발생시킨다.

```js
function foo() {
  var x = 1;
  // var 키워드로 선언된 변수는 같은 스코프 내에서 중복 선언을 허용
  // 아래 변수 선언문은 자바스크립트 엔진에 의해 var 키워드가 없는 것처럼 동작

  var x = 2;

  console.log(x); //2
}
foo();
```

<br>
<br>

## 13.2 스코프의 종류

| 구분 | 설명                  | 스코프      | 변수      |
| ---- | --------------------- | ----------- | --------- |
| 전역 | 코드의 가장 바깥 영역 | 전역 스코프 | 전역 변수 |
| 지역 | 함수 몸체 내부        | 지역 스코프 | 지역 변수 |

<br>

- 전역과 전역 스코프

  - **_전역 변수는 어디서든 참조가 가능 (함수 내부에서도)_**

- 지역과 지역 스코프

  - 지역이란 함수 몸체 내부를 말함
  - **_지역 변수는 자신의 지역 스코프와 하위 지역 스코프에서 유효_**

<br>
<br>

## 13.3 스코프 체인

함수의 중첩 : 함수 몸체 내부에서 함수가 정의된 것

스코프가 함수의 중첩에 의해 **계층적 구조**를 갖는다.

```
스코프 체인(scope chine) : 스코프가 계층적으로 연결된 것

inner 지역 스코프 → outer 지역 스코프 → 전역 스코프
```

변수를 참조할 때 자바스크립트 엔진은 스코프 체인을 통해 변수를 참조하는 코드의 스코프에서 시작해 상위 스코프의 방향으로 이동하며 **_선언된 변수를 검색 identifier resolution_**

이를 통해서 상위 스코프에서 선언한 변수를 하위 스코프에서도 참조 가능

📄 스코프 체인은 실행 컨텍스트의 렉시컬 환경을 단방향으로 연결한 것이다. (23장에서 자세히)

```js
// 전역 함수
function foo() {
  console.log("global function foo");
}

function bar() {
  // 중첩 함수
  function foo() {
    console.log("local function foo");
  }

  foo(); // ①
}

bar();
```

①에서 호출한 foo함수는 전역에 선언한 foo함수가 아니라 bar함수 내부에 선언한 foo함수를 호출 하는 것이다.

①에서 foo();를 호출하면 현재 실행 중인 실행컨텍스트(bar함수)의 렉시컬 환경에서 foo식별자를 먼저 검색한다.

있으면 그 식별자를 참조하고, 없는경우 외부 렉시컬환경(상위 렉시컬 환경)으로 가서 찾기를 반복한다.

이를 **_"식별자를 검색하는 규칙"_** 이라고 표현

<br>
<br>

## 13.4 함수 레벨 스코프

지역은 함수 몸체 내부를 말하고 지역은 지역 스코프를 만든다. **코드 블록이 아닌 함수에 의해서만 지역 스코프가 생성된다는 의미**다.

if, for, while try/catch 등의 코드 블록은 **_블록 레벨 스코프_** 를 만든다.

```js
var x = 1;

if (true) {
  // var 키워드로 선언된 변수는 함수의 코드 블록(함수 몸체)만을 지역 스코프로 인정
  // 함수 밖에서 var 키워드로 선언된 변수는 코드 블록 내에서 선언되었다 할지라도 모두 전역 변수
  // 따라서 x는 전역 변수다. 이미 선언된 전역 변수 x가 있으므로 x 변수는 중복 선언됨
  // 이는 의도치 않게 변수 값이 변경되는 부작용을 발생시킨다.
  var x = 10;
}

console.log(x); // 10
```

```js
var i = 10;

// for 문에서 선언한 i는 전역 변수다. 이미 선언된 전역 변수 i가 있으므로 중복 선언된다.
for (var i = 0; i < 5; i++) {
  console.log(i); // 0 1 2 3 4
}

// 의도치 않게 변수의 값이 변경되었다.
console.log(i); // 5
```

마찬가지로 for문 안에에서 var i = 0으로 i변수를 선언했지만 전역 변수로 등록되어 for문 바깥에서도 참조할 수 있음

<br>
<br>

## 13.5 렉시컬 스코프

```js
var x = 1;

function foo() {
  var x = 10;
  bar();
}

function bar() {
  console.log(x);
}

foo(); // ?
bar(); // ?
```

결과는 둘다 1이 출력된다.

이유는 함수를 어디서 호출하는지에 따라 상위 스코프가 결정되는 것 이아니고,
함수를 **_어디에 정의했는지에 따라 함수의 상위 스코프가 결정_**

함수가 호출된 위치는 상위 스코프 결정에 어떠한 영향도 주지 않고, 언제나 함수가 정의된 위치가 중요하다. → **_렉시컬 스코프_** 를 따른다

1. 동적 스코프 : 함수를 어디서 **_호출_** 했는지에 따라 함수의 상위 스코프 결정

2. 렉시컬 스코프(정적 스코프) : 함수를 어디서 **_정의_** 했는지에 따라 함수의 상위 스코프 결정

💡 자바스크립트는 렉시컬 스코프를 따르므로 함수를 어디서 정의했는지에 따라 상위 스코프를 결정한다.

<br>
