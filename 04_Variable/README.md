# 4장 변수

<br>

## 4.1 변수란 무엇인가? 왜 필요한가?

```
ex) 10 + 20
```

컴퓨터는 CPU를 사용해 연산하고, 메모리를 사용해 데이터를 기억

> 💡 **메모리 (memory)** : 데이터를 저장할 수 있는 메모리 셀의 집합체

메모리 셀 하나의 크기는 1바이트(비트)이며, 컴퓨터는 메모리 셀의 크기, 즉 1바이트 단위로 데이터를 저장하거나 읽어 들인다.

- 각 셀은 **고유의 메모리 주소**를 갖음

```
이 메모리 주소는 메모리 공간의 위치를 나타내며, 0부터 시작해서 메모리의 크기만큼 정수로 표현

ex) 4GB → 4,294,967,295(0x00000000 ~ 0xFFFFFFFF)까지의 메모리 주소를 갖음

모든 데이터(종류 상관 x)는 2진수로 처리
```

연산 결과(30)가 메모리에 저장되었지만, 결과를 재사용하기 위해서는 메모리 주소를 통해 연산 결과가 저장된 메모리에 **직접 접근**해야하는데 이는 치명적인 오류를 발생시킬 수 있어 **위험**함 (허용하더라도 **상황에 따라 임의로 결정**되는 메모리 주소에 직접 접근은 올바른 방법이 아님)
→ 따라서 자바스크립트는 개발자의 직접 메모리 제어를 허용 X
<br>

> 💡 프로그래밍 언어는 기억하고 싶은 값을 메모리에 저장하고, 그 값을 읽어 들여 재사용하기위해 **변수**라는 메커니즘 제공

```
변수(variable)는 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름
```

```js
// 변수는 하나의 값을 저장하기 위한 수단
var userId = 1;
var userName = "Lee";

// 객체나 배열 같은 자료구조를 사용하면 여러 개의 값을 하나로 그룹화해서 하나의 값처럼 사용할 수 있다.
var user = { id: 1, name: "Lee" };

var users = [
  { id: 1, name: "Lee" },
  { id: 2, name: "Kim" },
];
```

- **할당(assignment)** : 변수에 값을 **저장**
- **참조(reference)** : 저장된 값을 **읽어 들이는 것**

> 코드는 컴퓨터에게 내리는 명령이지만 개발자를 위한 문서이기도 함 → 의미를 파악할 수 있는 변수명으로 가독성을 높이자!

<br>
<br>

## 4.2 식별자

```
어떤 값을 구별해서 식별할 수 있는 고유한 이름으로 값을 저장하고 있는 주소와 매핑 관계
```

💡 식별자는 **선언**에 의해 자바스크립트 엔진에 존재를 알리고, 값이 아니라 **메모리 주소**를 기억

<br>
<br>

## 4.3 변수 선언 (variable declaration)

```
변수를 생성하는 것으로, 값을 저장하기 위한 메모리 공간을 확보하고 그 공간의 주소와 변수 이름을 연결하여 값을 저장할 수 있게 준비하는 것
```

> 💡 **변수를 사용하려면 반드시 선언이 필요하며 `var`, `let`, `const` 키워드를 사용**

- `var` : 대표적 단점으로 블록 레벨 스코프 지원 X (**함수 레벨 스코프 지원**) → 의도치 않게 **전역 변수**가 선언되는 심각한 부작용

ES6에서 **`var`** 의 여러 단점을 보완하기 위하여 `let` 과 `const` 도입!

<br>

📄 **키워드** : 코드를 해석하고 실행하는 자바스크립트 엔진이 수행할 **동작**을 규정한 **일종의 명령어**로 변수 선언에 의해 확보된 메모리 공간에는 **undefined**라는 값이 암묵적으로 할당되어 초기화된다.

<br>

📄 **undefined** : 자바스크립트에서 제공하는 원시 타입의 값(primitive value)

변수 선언을 다음과 같은 2단계에 거쳐 수행

- **선언 단계** : 변수 이름을 등록해서 자바스크립트 엔진에 변수의 존재를 알림
- **초기화 단계** : 값을 저장하기 위한 메모리 공간을 확보하고 암묵적으로 undefined를 할당해 초기화

<br>

📄 **변수 이름은 어디에 등록되는가?**

변수 이름을 비롯한 모든 식별자 → **실행 컨텍스트**에 등록, 식별자와 스코프 관리

- 실행 컨텍스트 : 자바스크립트 엔진이 소스코드를 평가, 실행하기 위해 필요한 환경 제공하고 코드의 실행 결과를 실제로 관리하는 영역

`var` 키워드는 선언 단계와 초기단계 **동시에 진행**됨

일반적으로 초기화란 변수가 선언된 이후 최초로 값을 할당하는 것을 말하는데, `var` 키워드로 선언한 변수는 값을 할당하지 않아도 undefined 값을 갖음

초기화 단계를 거치지 않으면 이전에 다른 애플리케이션이 **사용했던 값(garbage value)** 이 남아있을 수 있는데, `var` 키워드의 암묵적 초기화 수행으로 값을 할당하지 않고 바로 변수값을 참조해도 이러한 위험으로부터 안전

<br>
<br>

## 4.4 변수 선언의 실행 시점과 변수 호이스팅

```js
console.log(score); // undefined

var score;

// 코드에서 나중에 변수를 선언 했으므로 참조에러가 발생할 것 같지만,
// 변수 선언이 런타임이 아닌, 그 이전 단계에서 먼저 실행되기 때문에
// 에러 발생 x, undefined가 출력
```

💡 변수 선언(선언 단계와 초기화 단계)이 소스코드가 순차적으로 실행되는 **런타임 이전 단계**에서 먼저 실행된다는 증거이며, 선언문이 코드의 선두로 **올려진 것처럼** 동작하는 특징을 **변수 호이스팅**이라 한다.

<br>
<br>

## 4.5 값의 할당

```js
var score; // 변수 선언
score = 80; // 값의 할당, 할당 연산자 =를 사용
```

```js
var score = 80; // 변수 선언과 값의 할당 단축 표현
```

자바스크립트 엔진은 변수 선언과 값의 할당을 하나의 문으로 단축 표현해도 변수 선언과 값의 할당을 2개의 문으로 나누어 각각 실행

💡 변수 선언과 값의 할당의 실행 시점이 다름

```js
console.log(score); // undefined

var score; // ① 변수 선언, 런타임 전에 먼저 실행
score = 80; // ② 값의 할당, 런타임에 실행

console.log(score); // 80, undefined에서 재할당
```

> 변수에 값 할당할 때 이전 값 undefined가 저장되어있던 메모리 공간을 지우고 할당 값 80을 새롭게 저장 X, **새로운 메모리 공간 확보 → 그곳에 할당 값 80 저장**

<br>
<br>

## 4.6 값의 재할당

```js
var score = 80; // 변수 선언과 값의 할당
score = 90; // 값의 재할당
```

변수에 값을 재할당하면 이전 값 80에서 재할당 값 90으로 변경 → score 변수의 이전 값인 undefined와 80이 더 이상 불필요 → **가비지 콜렉터**에 의해 메모리에서 자동 해제

📄 **가비지 콜렉터 (garbage collector)** : 애플리케이션이 할당한 메모리 공간을 주기적으로 검사하여 **더 이상 사용되지 않는** 메모리를 해제하는 기능 → **메모리 누수(memory leak)** 방지

📄 **`const` 키워드** : `const` 키워드를 사용해 선언한 변수는 재할당이 금지됨. 즉 한번만 할당할 수 있는 변수 선언 (상수 표현)

📄 **언매니지드 언어와 매니지드 언어** : 메모리 관리 방식으로 분류

```
언매니지드 언어는 메모리 제어를 개발자가 주도할 수 있으므로 역량에 따라 최적의 성능 확보 가능(오류 생산도 가능)
매니지드 언어는 개발자의 직접적인 메모리 제어 허용 X (가비지 콜렉터가 수행)
```

<br>
<br>

## 4.7 식별자 네이밍 규칙

```
식별자(identifier)는 어떤 값을 구별해서 식별해낼 수 있는 고유한 이름
```

- 식별자는 특수문자를 제외한 **문자, 숫자, 언더스코어(\_), $** 포함 가능
- 단, 숫자로 시작하는 것은 허용 X
- 예약어는 식별자로 사용할 수 없음

> naming convention

일반적으로

변수나 함수 → camelCase

생성자 함수, 클래스의 이름 → PascalCase

```js
// camelCase
var firstName;

// snake_case
var first_name;

// PascalCase
var FirstName;

//typeHungarianCase
var strFirsrName; // type + identifier
var $elem = document.getElementById("myId"); // DOM 노드
```

<br>
