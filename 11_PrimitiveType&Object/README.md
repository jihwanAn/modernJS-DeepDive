# 11장 원시 값과 객체의 비교

[6장 데이터 타입](https://github.com/jihwanAn/modernJs-DeepDive/tree/main/06_DataType) 에서 보았던 7가지 데이터 타입 → **_원시 타입_** 과 **_객체타입_** 으로 구분 가능

💡 크게 세 가지 측면에서 다름

- 원시 타입 값은 **_immutable value_**, 객체(참조) 타입 값은 **_mutable value_**
- 원시 값을 변수에 할당 → 변수에는 **_실제 값_** 저장, 객체는 **참조 값이 저장**
- 원시 값을 갖는 변수를 다른 변수에 할당 → 원본의 원시 값 복사되어 전달(**_값에 의한 전달_** 이라함), 객체는 원본의 참조 값이 복사되어 전달(**_참조에 의한 전달_** )
  <br>
  <br>

## 11.1 원시 값

### 11.1.1 변경 불가능한 값

```
원시 타입(primitive type) 의 값 → 변경 불가능한 값(immutable value)
```

```js
// 변경이 불가능하다는 것은 변수가 아니라 값에 대한 진술

// const 사용해 선언한 변수 = 재할당 금지됨
const o = {};

// const 사용해 선언한 변수에 할당한 원시 값은 변경 못하지만,
// 할당한 객체는 변경할 수 있음

o.a = 1;
console.log(o); // {a:1}
```

원시 값은 어떤 일이 있어도 **_불변성_** (**원시값을 할당한 변수는 재할당 이외에 변수 값을 변경할 수 있는 방법이 없다.**)

💡 원시값을 재할당 하면 새로운 메모리 공간 확보 → 재할당 값 저장 → 변수가 참조하던 **_메모리 공간의 주소 변경_**

<br>

### 11.1.2 문자열과 불변성

> **0개 이상의 문자로 이뤄진 집합, 1개의 문자는 2바이트의 메모리 공간에 저장**

C는 문자열을 문자의 배열로 처리, 자바는 String 객체로 처리,
자바스크립트에서는 개발자의 편의 위해서 원시 타입인 문자열 타입 제공

```js
var str = "Hello";
str = "world";

// 새로운 문자열 "world"도 메모리에 생성한 뒤, str이 "world"를 가리키도록
```

📄 유사 배열 객체란? 배열처럼 인덱스로 프로퍼티 값에 접근 가능하고, length 프로퍼티를 갖음 (원시 값을 객체처럼 사용하면 원시 값을 감싸는 래퍼 객체로 자동 변환됨 - **_21.3 에서 자세히_** )

문자열은 유사 배열이므로 인덱스를 사용해 각 문자에 접근할 수 있지만, 원시 값이므로 변경은 X.

<br>

### 11.1.3 값에 의한 전달

```js
var score = 80;
var copy = score;

console.log(score); // 80
console.log(copy); // 80

score = 100;

console.log(score); // 100
console.log(copy); // 80
```

변수에 원시 값을 갖는 변수를 할당하면 할당받는 변수(copy)에는 할당되는 변수(score)의 원시 값이 복사되어 전달 (값의 전달 이라고 함)

엄격하게 표현하면 변수에는 **_값이 전달되는 것이 아님_** → 메모리의 주소가 전달되고, 변수와 같은 식별자는 값이 아니라 **_메모리 주소를 기억_**

💡 이처럼 **"값의 의한 전달"** 도 사실 **_메모리 주소_** 를 전달 (**_두 변수의 원시 값은 어느 한쪽에서 재할당을 통해 값을 변경해도 서로 간섭 못함_** )

<br>
<br>

## 11.2 객체

```
객체는 프로퍼티 수, 프로퍼티 값에 제약이 없이 동적일 수 있음(원시 값에 비해 복합적인 자료구조)
```

📄 자바스크립트 객체의 관리 방식은 **_프로퍼티 키를 인덱스로 사용하는 해시 테이블_** 이다. 타 객체지향 프로그래밍 언어와 달리 자바스크립트는 **_클래스 없이 객체를 생성_** 가능, 객체 생성 이후라도 동적으로 프로퍼티와 메서드 추가 가능 (사용은 편리하지만 이론적으로 클래스 기반 객체지향 프로그래밍 언어의 객체보다 생성, 프로퍼티 접근에 비용이 더 많이 든다.)

→ V8 엔진에서는 **_히든 클래스_** 라는 방식을 사용

<br>

### 11.2.1 변경 가능한 값

**_객체(참조) 타입의 값, 즉 객체는 변경 가능한 값_**

객체를 할당한 변수가 기억하는 메모리 주소를 통해 메모리 공간에 접근하면
**_참조 값_** 에 접근할 수 있다.

```js
// 할당이 이뤄지는 시점에 객체 리터럴이 해석되고, 그 결과 객체가 생성
var person = {
  name: "Lee",
};

// person 변수에 저장되어 있는 참조 값으로 실제 객체에 접근
console.log(person); // {name: "Lee"}

// 객체는 재할당 없이 직접 변경이 가능
var person = {
  name: "Lee",
};

person.name = "Kim";

person.address = "Seoul";

console.log(person); // {name: "Kim", address: "Seoul"}
```

객체는 원시 값과 달리 크기가 일정하지 않고, 프로퍼티 값이 객체일 수도 있어서 복사해서 생성하는 비용이 많이 든다.

따라서 효율적으로 사용하기 위해, 변경 가능한 값으로 설계가 되어있는데, 이러한 구조로 인해 **_여러 개의 식별자가 하나의 객체를 공유할 수 있다_** 는 부작용이 있음

<br>

📄 얕은 복사와 깊은 복사

```js
const o = { x: { y: 1 } };

// 얕은 복사
const c1 = { ...o }; // 35장 "스프레드 문법" 참고
console.log(c1 === o); // false
console.log(c1.x === o.x); // true

// lodash의 cloneDeep을 사용한 깊은 복사
// "npm install lodash"로 lodash를 설치 후, Node.js 환경에서 실행
const require("lodash");

// 깊은 복사
const c2 = _.cloneDeep(o);
console.log(c2 === o); // false
console.log(c2.x === o.x); // false

// 얕은 복사 → 객체에 중첩되어 있는 객체의 경우 참조 값을 복사
// 깊은 복사 → 객체에 중첩되어 있는 객체까지 모두 복사해서 원시 값처럼 완전한 복사본을 만든다.


const v = 1;

// 원시 값을 할당한 변수를 다른 변수에 할당하는 것 : 깊은 복사라고도 함
const c1 = v;
console.log(c1 === v); // true

const o = { x: 1 };

// 객체를 할당한 변수를 다른 변수에 할당하는 것 : 얕은 복사라고도 함
const c2 = o;
console.log(c2 === o); // true
```

<br>

### 11.2.2 참조에 의한 전달

```js
var person = {
  name: "Lee",
};

// 참조 값을 복사(얕은 복사)
var copy = person;
```

객체를 가리키는 변수(원본, person)를 다른 변수(사본, copy)에 할당하면, 원본 의참조 값이 복사되어 전달되는 것을 **_참조에 의한 전달_** 이라 한다.

```
person을 사본 copy에 할당하면 원본 person의 참조값 복사해서 copy에 저장.
person 과 copy는 메모리 주소는 다르지만 동일한 참조 값을 갖음.

💡 두 개의 식별자가 하나의 객체를 공유한다는 것을 의미
→ 서로 영향을 주고 받음
```

결국 **_값에 의한 전달_** 과 **_참조에 의한 전달_** 은 식별자가 기억하는 메모리 공간에 저장되어 있는 값을 복사해서 전달한다는 면에서 동일하지만 변수에 저장되어 있는 값이 원시 값이냐 참조 값이냐의 차이만 있을 뿐이다.

자바스크립트에는 **_값에 의한 전달_** 만 존재

```js
var person1 = {
  name: "Lee",
};
var person2 = {
  name: "Lee",
};

console.log(person1 === person2); // false, 각자 가리키는 객체는 다른 메모리에 저장된 별개의 객체
console.log(person1.name === person2.name); // true, 프로퍼티 값을 참조하기 때문에 값으로 평가될 수 있고 모두 원시값 "Lee"로 평가
```

<br>
