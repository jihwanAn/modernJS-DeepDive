# 6장 데이터 타입

<br>

```
ES6는 원시 타입과 객체타입으로 분류할 수 있는 7개의 데이터 타입을 제공
```

> 원시 타입

- **Number 타입** : 숫자, 정수와 실수 구분 없이 하나의 숫자 타입만 존재
- **String 타입** : 문자열
- **Boolean 타입** : 논리적 true / false
- **undefined 타입** : `var` 키워드로 선언된 변수에 암묵적 할당되는 값
- **null 타입** : 값이 없다는 것을 의도적으로 명시할 때
- **symbol 타입** : ES6에 추가된 7번째 타입

> 객체 타입

- 객체, 함수, 배열 등

<br>
<br>

## 6.1 숫자 타입

> C나 자바의 경우, 정수와 실수 구분해서 int, long, float, double 등과 같은 다양한 숫자 타입 제공하지만, **자바스크립트는 하나의 숫자 타입만 존재**

정수, 실수, 2진수, 8진수, 16진수 리터럴 → 모두 메모리에 배정밀도 64비트 부동소수점 형식의 2진수로 저장

자바스크립트는 2진수, 8진수, 16진수를 표현하기 위한 데이터 타입을 제공 X, 이들 값을 참조하면 **모두 10진수**로 해석

```js
var binary = 0b0100001; // 2진수
var octal = 0o101; // 8진수
var hex = 0x41; // 16진수

// 표기법만 다를뿐 모두 같은 값(65) 이다.
```

자바스크립트의 숫자 타입은 정수만을 위한 타입 X → 모든 수를 **실수**로 처리

```js
// 숫자 타입의 세 가지 특별한 값
console.log(10 / 0); // Infinity : 양의 무한대
console.log(10 / 0); // -Infinity : 음의 무한대
console.log(1 * "String"); // NaN : 산술 연산 불가
```

<br>
<br>

## 6.2 문자열 타입

```
0개 이상의 16비트 유니코드 문자(UTF-16)의 집합으로 텍스트 데이터를 나타내는 데 사용

(''), (""), (``)으로 텍스트 감싸줌
```

**C** : 문자열 타입을 제공 X, 문자의 배열로 문자열 표현

**자바** : 문자열을 객체로 표현

**자바스크립트** : 원시 타입의 문자열, 변경 불가능한 값

<br>
<br>

## 6.3 템플릿 리터럴

```
ES6 부터 런타임에 일반 문자열로 변환 처리 되는 새로운 문자열 표기법 template literal 도입
```

일반 문자열과 달리 템플릿 리터럴 내에서는 이스케이프 시퀀스 사용하지 않고도 줄바꿈이 허용됨(공백도 그대로 적용)

- 멀티라인 문자열(multi-line string) : 일반 문자열 내 줄바꿈(개행) 허용 X → 줄바꿈 등의 공백 표현은 백슬래시로 시작하는 이스케이프 시퀀스 사용

  > escape sequence

  - **\0** : NUll
  - **\b** : 백스페이스
  - **\f** : Form Feed : 프린터로 출력할 경우 다음 페이지의 시작 지점으로 이동
  - **\n** : 개행\_LF, Line Feed : 다음 행으로 이동
  - **\r** : 개행\_CR, Carriage Return : 커서를 처음으로 이동
  - **\t** : 탭 (수평)
  - **\v** : 탭 (수직)
  - **\uXXXX** : 유니코드, ex) \u0041 = 'A', \uD55C = '한'
  - **\'** : 작은따옴표
  - **\"** : 큰따옴표
  - **\\\\** : 백슬래시

  ```
  📄 라인 피트와 캐리지 리턴
  개행문자는 텍스트의 한 줄이 끝남을 표시하는 문자 또는 문자열 → 라인피드_LF 와 캐리지 리턴_CR 이 있음
  과거 타자기 커서 제어방식 \n(커서 정지, 종이 한 줄 올림) \r(종이 움직이지 않고 커서를 맨 앞줄로 이동)
  현대의 컴퓨터 운영체제는 서로 다른 체계의 개행 방식 사용
  윈도우는 CR+LF 로 새 줄, 유닉스는 LF 로 새 줄, macOS는 버전10부터 LF를 사용
  💡 다른 운영체제에서 작성한 텍스트 파일은 서로 개행 문자를 인식하지 못함 → 대부분의 텍스트 에디터는 운영체제에 맞게 개행 문자를 자동 변환해줌
  js에서는 일반적으로 \n 사용
  ```

- 표현식 삽입(expression interpolation)

  문자열은 피연산자 중 하나 이상 문자열인경우 + 사용해 연결

  ```js
  // 표현식 삽입은 ${} 으로 표현식을 감싼다
  var first = "A";
  var last = "NN";

  console.log(`My name is ${first}${last}.`);
  // My name is ANN.
  ```

- 태그드 템플릿 (tagged template)

<br>
<br>

## 6.4 불리언 타입

```
불리언 타입의 값은 논리적 true, false 뿐이다
```

<br>
<br>

## 6.5 undefined 타입

```
var 키워드로 선언한 변수는 암묵적으로 undefined로 초기화됨 → 변수 선언 후 값을 할당하지 않은 변수를 참조하면 undefined 반환
```

변수 참조 시 undefined 반환은 참조한 변수가 선언 이후 **값이 할당된 적이 없는**, 즉 초기화되지 않은 변수

💡 undefined를 개발자 직접 사용하면 혼란을 줄 수 있어 권장 X, 그런 경우엔 **null 할당**

<br>
<br>

## 6.6 null 타입

```
프로그래밍 언어에서 null은 변수에 값이 없다는 것을 의도적으로 명시(의도적 부재_intentional absence)
변수에 null을 할당하는 것 → 변수가 이전 참조 값을 더 이상 참조하지 않겠다.
```

함수가 유효한 값을 반환할 수 없는 경우 명시적으로 null을 반환하기도 한다.
ex) HTML 요소를 검색해 반환하는 `document.querySelector` 는 조건에 부합하는 HTML 요소를 검색할 수 없는 경우 에러 대신 null을 반환

<br>
<br>

## 6.7 심벌 타입

```
ES6에서 추가된 7번째 타입, 변경 불가능한 원시 타입의 값
다른 값과 중복되지 않는 유일무이한 값
```

💡 이름이 충돌할 위험이 없는 객체의 유일한 프로퍼티 키를 만들기 위해 사용

```js
// 심벌 값 생성
var key = Symbol("key");
console.log(typeof key); // symbol

// 객체 생성
var obj = {};

// 이름이 충돌할 위험이 없는 유일무이한 값인 심벌을 프로퍼티 키로 사용
obj[key] = "value";
console.log(obj[key]); // value
```

<br>
<br>

## 6.8 객체 타입

```
크게 원시 타입과 객체 타입으로 분류
```

💡 자바스크립트는 객체 기반의 언어이며, **_자바스크립트를 이루고 있는 거의 모든 것이 모든 것이 객체_** , 6가지 타입 이외의 값은 모두 객체 타입

<br>
<br>

## 6.9 데이터 타입의 필요성

### 6.9.1 데이터 타입에 의한 메모리 공간의 확보와 참조

메모리에 값을 저장하려면 확보해야할 메모리 공간 크기 결정해야 함 → 몇 바이트의 **메모리 공간**을 사용해야 **낭비와 손실 없이** 값을 저장할 수 있는지

```js
var score = 100;

// 리터럴 100 => 숫자 타입의 값으로 해석
// 숫자 타입 100 저장하기 위해 8바이트 메모리공간 확보
// 100을 2진수로 저장

// ! 자바스크립트 엔진은 데이터 타입에 따라 정해진 크기의 메모리 공간 확보
```

📄 데이터 타입에 따라 확보되는 메모리 공간의 크기

```
ECMAScript 사양은 문자열,숫자 타입 외 데이터 타입 크기를 명시적으로 규정 X,
자바스크립트 엔진 제조사의 구현에 따라 다를 수 있음

숫자타입은 배정밀도 64비트 부동소수점 형식 사용 명시, 배정밀도 64비트 부동소수점 형식은 8바이트로 숫자를 표현
```

**_값을 참조하는 경우 ,_**

score(식별자)를 통해 100 이 저장되어있는 메모리 공간의 선두 메모리 셀의 주소를 찾아감 → 한 번에 읽어 들여야 할 메모리 셀의 개수(바이트 수)를 알아야함

변수에 8바이트 단위로 저장되는 **숫자 타입의 값**이 할당되어 있으므로, score 참조 → 8바이트 단위로 메모리 공간에 저장된 값을 읽어 들임

📄 심벌 테이블

```
컴파일러 또는 인터프리터는 심벌 테이블이라고 부르는 자료 구조를 통해 식별자를 키로 바인딩된 값의 메모리 주소, 데이터 타입, 스코프 등을 관리
```

<br>

### 6.9.2 데이터 타입에 의한 값의 해석

그렇다면 메모리에서 읽어들인 2진수는 어떻게 해석할까?

모든 값은 메모리에 2진수, 비트의 나열로 저장

저장된 값은 데이터 타입에 따라 다르게 해석될 수 있음

```
ex) 메모리 저장된 값 : 0100 0001
숫자로 해석 → 65
문자열로 해석 → 'A'
```

💡 **데이터 타입 필요 이유**

- 값을 저장할 때 확보해야 하는 **메모리 공간의 크기**를 결정하기 위해
- 값을 참조할 때 한 번에 읽어 들여야 할 **메모리 공간의 크기**를 결정하기 위해
- 메모리에서 읽어 들인 **2진수를 어떻게 해석**할지 결정하기 위해

<br>
<br>

## 6.10 동적 타이핑

### 6.10 동적 타입 언어와 정적 타입 언어

변수는 데이터 타임을 가질까? → 기본적으로 타입을 갖지 않고, 변수에 할당되어 있는 값에 의해 변수의 타입이 **_동적_** 으로 결정

C나 자바 같은 **정적 타입 언어**는 변수를 선언할 때 변수에 할당할 수 있는 값의 종류, 즉 데이터 타입을 **사전에 선언(명시적 타입 선언)**

컴파일 시점 **타입 체크**를 수행해 타입의 일관성을 강제

대표적 : C, C++, 자바, 코틀린, 고, 하스켈, 러스트, 스칼라 등

```C
// c 변수에는 1바이트 정수 타입의 값(-128 ~ 127)만 할당할 수 있다.
char c;

// num 변수에는 4바이트 정수 타입의 값(-2,124,483,648 ~ 2,124,483,647)만 할당할 수 있다.
int num;
```

자바스크립트는 정적 타입언어와 다르게 `var`, `let`, `const` 키워드로 변수를 선언할 뿐 변수 선언 시 타입 선언 X

💡 **`typeof`** 연산자 : 변수에 할당된 값의 데이터 타입 반환

```js
foo = "Hello";
console.log(typeof foo); // string

foo = null;
console.log(typeof foo); // object

foo = {}; // 객체
console.log(typeof foo); // object

foo = []; // 배열
console.log(typeof foo); // object

foo = function () {}; // 함수
console.log(typeof foo); // function
```

**자바스크립트의 변수는 선언이 아닌 할당에 의해 타입이 결정되고, 재할당에 의해 변수의 타입은 언제든지 동적으로 변할 수 있다.**

대표적 동적 타입 언어 : 자바스크립트, 파이썬, PHP, 루비, 리스프, 펄 등

### 6.10.2 동적 타입 언어와 변수

동적 타입 언어는 유연성은 높지만, 복잡한 프로그램에서는 변화하는 변수 값 추적이 어려워 신뢰성은 떨어지는 단점이 있다.

> 💡 변수 사용시 주의사항

- 꼭 필요한 경우 제한적 사용
- 변수의 유효 범위(스코프)는 최대한 좁게
- 전역 변수는 최대한 사용 X
- 변수보다는 상수 사용으로 값의 변경을 억제
- 변수(모든 식별자 포함) 네이밍은 목적이나 의미를 파악할 수 있도록

<br>
